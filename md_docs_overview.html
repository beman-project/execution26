<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::execution26: overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">beman::execution26
   </div>
   <div id="projectbrief">Building Block For Asynchronous Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
std::execution Overview</h1>
<p>This page provides an overview of the components in <code>std::execution</code>. The documentation on this page doesn’t represent all details of the specification. However, it should capture enough details to be a suitable resource to determine how the various components are used.</p>
<p>For each of the components a summary view is provided. To get more details expand the respective section. </p>
<h2><a class="anchor" id="autotoc_md1"></a>
Terms</h2>
<p>This section defines a few terms used throughout the description on this page. The terms aren’t taken from the specification and are, thus, somewhat informal.</p>
<details >
<summary >
completion signal</summary>
<p>When an asynchronous operation completes it <em>signals</em> its completion by calling a completion function on a <code><a href="‘#receiver’">receiver</a></code>:</p>
<ul>
<li><code><a href="‘#set-value’">std::execution::set_value</a>(<em>receiver</em>, <em>args</em>...)</code> is called when an operation completes successfully. A call to this completion function is referred to as <em>value completion signal</em>.</li>
<li><code><a href="‘#set-error’">std::execution::set_error</a>(<em>receiver</em>, <em>error</em>)</code> is called when an operation fails to deliver its success results. A call to this completion function is referred to as <em>error completion signal</em>.</li>
<li><code><a href="‘#set-stopped’">std::execution::set_stopped</a>()</code> is called when an operation was cancelled. A call to this completion function is referred to as <em>cancellation completion signal</em>.</li>
<li>Collectively the value, error, and cancellation completion signals are referred to as <em>completion signal</em>. Note that any <code><a href="‘#start’">start</a></code>ed asynchronous operation triggers exactly one completion signal. </li>
</ul>
</details>
<details >
<summary >
environment</summary>
<p>The term <em>enviroment</em> refers to the bag of properties associated with an <code><em>object</em></code> by the call <code><a href="‘#get-env’">std::execution::get_env</a>(<em>object</em>)</code>. By default the environment for objects is empty (<code><a href="‘#empty-env’">std::execution::empty_env</a></code>). In particular, environments associated with <code><a href="‘#receiver’">receiver</a></code>s are used to provide access to properties like the <a href="‘#get-stop-token’">stop token</a>, <a href="‘#get-scheduler’">scheduler</a>, or <a href="‘#get-allocator’">allocator</a> associated with the <code><a href="‘#receiver’">receiver</a></code>. The various properties associated with an object are accessed via <a href="‘#queries’">queries</a>. </p>
</details>
<h2><a class="anchor" id="autotoc_md2"></a>
Concepts</h2>
<p>This section lists the concepts from <code>std::execution</code>.</p>
<details >
<summary >
<code>operation_state&lt;<em>State</em>&gt;</code></summary>
<p></p>
<p>Operation states represent asynchronous operations ready to be <code><a href="‘#start’">start</a></code>ed or executing. Operation state objects are normally neither movable nor copyable. Once <code><a href="‘#start’">start</a></code>ed the object needs to be kept alive until a <a href="‘#completion-signal’">completion signal</a> is received. Users don’t interact with operation states explicitly except when implementing new sender algorithms.</p>
<p>Required members for <code><em>State</em></code>:</p>
<ul>
<li>The type <code>operation_state_concept</code> is an alias for <code>operation_state_t</code> or a type derived thereof.</li>
<li><code><em>state</em>.<a href="‘#start’">start</a>() &amp; noexcept</code></li>
</ul>
<details >
<summary >
Example</summary>
<p></p>
<p>This example shows a simple operation state object which immediately completes successfully without any values (as <code><a href="‘#just’"></a>()</code> would do). Normally <code><a href="‘#start’">start</a>()</code> initiates an asynchronous operation completing at some point later.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">struct example_state</div>
<div class="line">{</div>
<div class="line">    using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">    std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line">    </div>
<div class="line">    auto start() &amp; noexcept {</div>
<div class="line">        std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::execution::operation_state&lt;example_state&lt;SomeReceiver&gt;&gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>receiver&lt;<em>Receiver</em>&gt;</code></summary>
<p></p>
<p>Receivers are used to receive <a href="‘#completion-signal’">completion signals</a>: when an asynchronous operation completes the corresponding <a href="‘#completion-signal’">completion signal</a> is called with the appropriate arguments. In addition receivers provide access to the <a href="‘#environment’">environment</a> for the operation via the <a href="‘#get-env’"><code>get_env</code></a> method. Users don’t interact with receivers explicitly except when implementing new sender algorithms.</p>
<p>Required members for <code><em>Receiver</em></code>:</p>
<ul>
<li>The type <code>receiver_concept</code> is an alias for <code>receiver_t</code> or a type derived thereof`.</li>
<li>Rvalues of type <code><em>Receiver</em></code> are movable.</li>
<li>Lvalues of type <code><em>Receiver</em></code> are copyable.</li>
<li><code><a href="‘#get-env’">std::execution::get_env</a>(<em>receiver</em>)</code> returns an object. By default this operation returns <code><a href="‘empty-env’">std::execution::empty_env</a></code>.</li>
</ul>
<p>Typical members for <code><em>Receiver</em></code>:</p>
<ul>
<li><code><a href="‘get_env’">get_env</a>() const noexcept</code></li>
<li><code><a href="‘set_value’">set_value</a>(args…) &amp;&amp; noexcept -&gt; void</code></li>
<li><code><a href="‘set_error’">set_error</a>(error) &amp;&amp; noexcept -&gt; void</code></li>
<li><code><a href="‘set_stopped’">set_stopped</a>() &amp;&amp; noexcept -&gt; void</code></li>
</ul>
<details >
<summary >
Example</summary>
<p></p>
<p>The example receiver prints the name of each the received <a href="‘#completion-signal’">completion signal</a> before forwarding it to a receiver. It forwards the request for an environment (<code><a href="‘#get_env’">get_env</a></code>) to the nested receiver. This example is resembling a receiver as it would be used by a sender injecting logging of received signals.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template &lt;std::execution::receiver NestedReceiver&gt;</div>
<div class="line">struct example_receiver</div>
<div class="line">{</div>
<div class="line">    using receiver_concept = std::execution::receiver_t;</div>
<div class="line">    std::remove_cvref_t&lt;NestedReceiver&gt; nested;</div>
<div class="line">    </div>
<div class="line">    auto get_env() const noexcept {</div>
<div class="line">        return std::execution::get_env(this-&gt;nested);</div>
<div class="line">    }</div>
<div class="line">    template &lt;typename… A&gt;</div>
<div class="line">    auto set_value(A&amp;&amp;… a) &amp;&amp; noexcept -&gt; void {</div>
<div class="line">        std::cout &lt;&lt; “set_value\n”;</div>
<div class="line">        std::execution::set_value(std::move(this-&gt;nested), std::forward&lt;A&gt;(a)…);</div>
<div class="line">    }</div>
<div class="line">    template &lt;typename E&gt;</div>
<div class="line">    auto set_error(E&amp;&amp; e) &amp;&amp; noexcept -&gt; void {</div>
<div class="line">        std::cout &lt;&lt; “set_error\n”;</div>
<div class="line">        std::execution::set_error(std::move(this-&gt;nested), std::forward&lt;E&gt;(e));</div>
<div class="line">    }</div>
<div class="line">    auto set_stopped() &amp;&amp; noexcept -&gt; void {</div>
<div class="line">        std::cout &lt;&lt; “set_stopped\n”;</div>
<div class="line">        std::execution::set_stopped(std::move(this-&gt;nested));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::execution::receiver&lt;example_receiver&lt;SomeReceiver&gt;&gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>receiver_of&lt;<em>Receiver, Completions</em>&gt;</code></summary>
<p></p>
<p>The concept <code>receiver_of&lt;<em>Receiver, Completions</em>&gt;</code> tests whether <code><a href="‘#receiver’">std::execution::receiver</a>&lt;<em>Receiver</em>&gt;</code> is true and if an object of type <code><em>Receiver</em></code> can be invoked with each of the <a href="‘#completion-signal’">completion signals</a> in <code><em>Completions</em></code>.</p>
<details >
<summary >
Example</summary>
<p></p>
<p>The example defines a simple <code><a href="‘#receiver’">receiver</a></code> and tests whether it models <code>receiver_of</code> with different <a href="‘#completion-signal’">completion signals</a> in <code><em>Completions</em></code> (note that not all cases are true).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct example_receiver</div>
<div class="line">{</div>
<div class="line">    using receiver_concept = std::execution::receiver_t;</div>
<div class="line">    </div>
<div class="line">    auto set_value(int) &amp;&amp; noexcept -&gt;void {}</div>
<div class="line">    auto set_stopped() &amp;&amp; noexcept -&gt;void {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// matching the exact signals models receiver_of:</div>
<div class="line">static_assert(std::execution::receiver_of&lt;example_receiver,</div>
<div class="line">    std::execution::completion_signals&lt;</div>
<div class="line">        std::execution::set_value_t(int),</div>
<div class="line">        std::execution::set_stopped_t()</div>
<div class="line">    &gt;);</div>
<div class="line">// providing a superset of signal models models receiver_of: </div>
<div class="line">static_assert(std::execution::receiver_of&lt;example_receiver,</div>
<div class="line">    std::execution::completion_signals&lt;</div>
<div class="line">        std::execution::set_value_t(int)</div>
<div class="line">    &gt;);</div>
<div class="line">// providing only a subset of signals doesn’t model receiver_of:</div>
<div class="line">static_assert(not std::execution::receiver_of&lt;example_receiver,</div>
<div class="line">    std::execution::completion_signals&lt;</div>
<div class="line">        std::execution::set_value_t(),</div>
<div class="line">        std::execution::set_value_t(int)</div>
<div class="line">    &gt;);</div>
</div><!-- fragment --> </details>
</details>
<details >
<summary >
<code>scheduler&lt;<em>Scheduler</em>&gt;</code></summary>
<p>Schedulers are used to specify the execution context where the asynchronous work is to be executed. A scheduler is a lightweight handle providing a <code><a href="‘#schedule’">schedule</a></code> operation yielding a <code><a href="‘sender’">sender with a value completion signal</a> without parameters. The completion is on the respective execution context.</code></p>
<p><code>Requirements for <code><em>Scheduler</em></code>:</p><ul>
<li>The type <code><em>Scheduler</em>::scheduler_concept</code> is an alias for <code>scheduler_t</code> or a type derived thereof`.</li>
<li><code><a href="‘#schedule’">schedule</a>(<em>scheduler</em>) -&gt; <a href="‘sender’">sender</a></code></li>
<li>The <a href="‘#get-completion-scheduler’">value completion scheduler</a> of the <code><a href="‘sender’">sender</a></code>’s <a href="‘#environment’">environment</a> is the <code><em>scheduler</em></code>: <em>scheduler</em> == std::execution::get_completion_scheduler&lt;std::execution::set_value_t&gt;( std::execution::get_env(std::execution::schedule(<em>scheduler</em>)) )</li>
<li><code>std::equality_comparable&lt;<em>Scheduler</em>&gt;</code></li>
<li><code>std::copy_constructible&lt;<em>Scheduler</em>&gt;</code> </li>
</ul>
<p></code></p>
</details>
<details >
<summary >
<code>sender&lt;<em>Sender</em>&gt;</code></summary>
<p><code> </code></p>
<p><code>Senders represent asynchronous work. They may get composed from multiple senders to model a workflow. Senders can’t be run directly. Instead, they are passed to a &lt;a href=‘::sender-consumer’ which <code><a href="‘#connect’">connect</a></code>s the sender to a <code><a href="‘#receiver’">receiver</a></code> to produce an <code><a href="‘#operation-state’">operation_state</a></code> which may get started. When using senders to represent work the inner workings shouldn’t matter. They do become relevant when creating sender algorithms.</code></p>
<p><code>Requirements for <code><em>Sender</em></code>:</p><ul>
<li>The type <code><em>Sender</em>::sender_concept</code> is an alias for <code>sender_t</code> or a type derived thereof or <code><em>Sender</em></code> is a suitable <em>awaitable</em>.</li>
<li><code><a href="get_env">std::execution::get_env</a>(<em>sender</em>)</code> is valid. By default this operation returns <code><a href="‘empty-env’">std::execution::empty_env</a></code>.</li>
<li>Rvalues of type <code><em>Sender</em></code> can be moved.</li>
<li>Lvalues of type <code><em>Sender</em></code> can be copied.</li>
</ul>
<p></code></p>
<p><code>Typical members for <code><em>Sender</em></code>:</p><ul>
<li><code><a href="‘get_env’">get_env</a>() const noexcept</code></li>
<li><code><a href="‘get_completion_signatures’">get_completion_signatures</a>(<em>env</em>) const noexcept -&gt; <a href="‘completion-signatures’">std::execution::completion_signatures</a>&lt;...&gt;</code></li>
<li><code><em>Sender</em>::completion_signatures</code> is a type alias for <code><a href="‘completion-signatures’">std::execution::completion_signatures</a>&lt;...&gt;</code> (if there is no <code><a href="‘get_completion_signatures’">get_completion_signatures</a></code> member).</li>
<li><code><a href="‘#connect’">connect</a>(<em>sender</em>, <a href="‘#receiver’">receiver</a>) -&gt; <a href="‘#operation-state’">operation_state</a></code></li>
</ul>
<p></code></p>
<p><code>&lt;detail&gt; </code></p>
<p><code>Example</code></p>
<p><code> The example shows a sender implementing an operation similar to <code><a href="‘#just’">just</a>(_value)</code>.</code></p>
<p><code></p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct example_sender</div>
<div class="line">{</div>
<div class="line">    template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">    struct state</div>
<div class="line">    {</div>
<div class="line">        using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">        std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line">        int                           value;</div>
<div class="line">        auto start() &amp; noexcept {</div>
<div class="line">            std::execution::set_value(</div>
<div class="line">                std::move(this-&gt;receiver),</div>
<div class="line">                this-&gt;value</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    using sender_concept = std::execution::sender_t;</div>
<div class="line">    using completion_signatures = std::execution::completion_signatures&lt;</div>
<div class="line">        std::execution::set_value_t(int)</div>
<div class="line">    &gt;;</div>
<div class="line">    </div>
<div class="line">    int value{};</div>
<div class="line">    template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">    auto connect(Receiver&amp;&amp; receiver) const -&gt; state&lt;Receiver&gt; {</div>
<div class="line">        return { std::forward&lt;Receiver&gt;(receiver), this-&gt;value };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(std::execution::sender&lt;example_sender&gt;);</div>
</div><!-- fragment --><p> </code></p>
</details>
<p><code> </p><details >
<summary >
<code>sender_in&lt;<em>Sender, Env</em> = std::execution::empty_env&gt;</code></summary>
<p></p>
<p>The concept <code>sender_in&lt;<em>Sender, Env</em>&gt;</code> tests whether <code><em>Sender</em></code> is a <code><a href="‘#sender’">sender</a></code>, <code><em>Env</em></code> is a destructible type, and <code><a href="‘#get_completion_signatures’">std::execution::get_completion_signatures</a>(<em>sender</em>, <em>env</em>)</code> yields a specialization of <code><a href="‘#completion_signatures’">std::execution::completion_signatures</a></code>. </p>
</details>
<details >
<summary >
<code>sender_to&lt;<em>Sender, Receiver</em>&gt;</code></summary>
<p></p>
<p>The concept <code>sender_to&lt;<em>Sender, Receiver</em>&gt;</code> tests if <code><a href="‘#sender_in’">std::execution::sender_in</a>&lt;<em>Sender</em>, <a href="#env_of_t">std::execution::env_of_t</a>&lt;<em>Receiver</em>&gt;&gt;</code> is true, and if <code><em>Receiver</em></code> can receive all <a href="‘#completion-signals’">completion signals</a> which can be sent by <code><em>Sender</em></code>, and if <code><em>Sender</em></code> can be <code><a href="‘#connect’">connect</a></code>ed to <code><em>Receiver</em></code>.</p>
<p>To determine if <code><em>Receiver</em></code> can receive all <a href="‘#completion-signals’">completion signals</a> from <code><em>Sender</em></code> it checks that for each <code><em>Signature</em></code> in <code><a href="‘#get_completion_signals’">std::execution::get_completion_signals</a>(<em>sender</em>, std::declval&lt;<a href="#env_of_t">std::execution::env_of_t</a>&lt;<em>Receiver</em>&gt;&gt;())</code> the test <code><a href="‘#receiver_of’">std::execution::receiver_of</a>&lt;<em>Receiver</em>, <em>Signature</em>&gt;</code> yields true. To determine if <code><em>Sender</em></code> can be <code><a href="‘#connect’">connect</a></code>ed to <code><em>Receiver</em></code> the concept checks if <code><a href="‘#connect’">connect</a>(std::declval&lt;<em>Sender</em>&gt;(), std::declval&lt;<em>Receiver</em>&gt;)</code> is a valid expression. </p>
</details>
<details >
<summary >
<code>sends_stopped&lt;<em>Sender, Env</em> = std::execution::empty_env&gt;</code></summary>
<p></p>
<p>The concept <code>sends_stopped&lt;<em>Sender, Env</em>&gt;</code> determines if <code><em>Sender</em></code> may send a <code><a href="‘#set_stopped’">stopped</a></code> <a href="‘#completion-signals’">completion signal</a>. To do so, the concepts determines if <code><a href="‘#get_completion_signals’">std::execution::get_completion_signals</a>(<em>sender</em>, <em>env</em>)</code> contains the signatures <code><a href="‘#set_stopped’">std::execution::set_stopped_t</a>()</code>. </p>
</details>
<details >
<summary >
<code>stoppable_token&lt;<em>Token</em>&gt;</code></summary>
<p>A <code>stoppable_token&lt;<em>Token</em>&gt;</code>, e.g., obtained via <code><a href="‘#get-stop-token’">std::execution::get_stop_token</a>(<em>env</em>)</code> is used to support cancellation of asynchronous operations. Using <code><em>token</em>.stop_requested()</code> an active operation can poll whether it was requested to cancel. An inactive operation waiting for a notification can use an object of a specialization of the template <code><em>Token</em>::callback_type</code> to get notified when cancellation is requested.</p>
<p>Required members for <code><em>Token</em></code>:</p>
<ul>
<li><code><em>Token</em>::callback_type&lt;<em>Callback</em>&gt;</code> can be specialized with a <code>std::callable&lt;<em>Callback</em>&gt;</code> type.</li>
<li><code><em>token</em>.stop_requested() const noexcept -&gt; bool</code></li>
<li><code><em>token</em>.stop_possible() const noexcept -&gt; bool</code></li>
<li><code>std::copyable&lt;<em>Token</em>&gt;</code></li>
<li><code>std::equality_comparable&lt;<em>Token</em>&gt;</code></li>
<li><code>std::swapable&lt;<em>Token</em>&gt;</code> <blockquote class="doxtable">
<details >
<summary >
Example: concept use</summary>
<div></div><div><div class="fragment"><div class="line"> {c++}</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::never_stop_token&gt;);</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::stop_token&gt;);</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::inline_stop_token&gt;);</div>
</div><!-- fragment --> </div> </details>
<details >
<summary >
Example: polling</summary>
<blockquote class="doxtable">
<p>This example shows a sketch of using a <code>stoppable_token&lt;<em>Token</em>&gt;</code> to cancel an active operation. The computation in this example is represented as <code>sleep_for</code>.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void compute(std::stoppable_token auto token)</div>
<div class="line">{</div>
<div class="line">    using namespace std::chrono::literals;</div>
<div class="line">    while (not token.stop_requested()) {</div>
<div class="line">         std::this_thread::sleep_for(1s);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </blockquote>
</details>
<details >
<summary >
Example: inactive</summary>
<blockquote class="doxtable">
<p>This example shows how an <code><a href="‘#operation-state’">operation_state</a></code> can use the <code>callback_type</code> together with a <code><em>token</em></code> to get notified when cancellation is requested.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template &lt;std::execution::receiver Receiver&gt;</div>
<div class="line">struct example_state</div>
<div class="line">{</div>
<div class="line">    struct on_cancel</div>
<div class="line">    {</div>
<div class="line">        example_state&amp; state;</div>
<div class="line">        auto operator()() const noexcept {</div>
<div class="line">            this-&gt;state.stop();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    using operation_state_concept = std::execution::operation_state_t;</div>
<div class="line">    using env = std::execution::env_of_t&lt;Receiver&gt;;</div>
<div class="line">    using token = std::execution::stop_callback_of_t&lt;env&gt;;</div>
<div class="line">    using callback = std::execution::stop_callback_of_t&lt;token, on_cancel&gt;;</div>
<div class="line">    std::remove_cvref_t&lt;Receiver&gt; receiver;</div>
<div class="line">    std::optional&lt;callback&gt;       cancel{};</div>
<div class="line">    std::atomic&lt;std::size_t&gt;      outstanding{};</div>
<div class="line">    auto start() &amp; noexcept {</div>
<div class="line">        this-&gt;outstanding += 2u;</div>
<div class="line">        this-&gt;cancel.emplace(</div>
<div class="line">            std::execution::get_stop_token(this-&gt;receiver),</div>
<div class="line">            on_cancel{*this}</div>
<div class="line">        );</div>
<div class="line">        if (this-&gt;outstanding != 2u)</div>
<div class="line">           std::execution::set_stopped(std::move(this-&gt;receiver));</div>
<div class="line">        else {</div>
<div class="line">           register_work(this);</div>
<div class="line">           if (this-&gt;outstanding == 0u)</div>
<div class="line">               std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    auto stop() {</div>
<div class="line">        unregister_work(this);</div>
<div class="line">        if (--this-&gt;outstanding == 0u)</div>
<div class="line">            std::execution::set_stopped(std::move(this-&gt;receiver));</div>
<div class="line">    }</div>
<div class="line">    auto complete() {</div>
<div class="line">        if (this-&gt;outstanding == 2u) {</div>
<div class="line">            this-&gt;cancel.reset();</div>
<div class="line">            std::execution::set_value(std::move(this-&gt;receiver));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};    </div>
</div><!-- fragment --> </blockquote>
</details>
</blockquote>
</li>
</ul>
</details>
<details >
<summary >
<code>unstoppable_token&lt;<em>Token</em>&gt;</code></summary>
<p>The concept <code>unstoppable_token&lt;Token&gt;</code> is modeled by a <code><em>Token</em></code> if <code>stoppable_token&lt;<em>Token</em>&gt;</code> is true and it can statically be determined that both <code><em>token</em>.stop_requested()</code> and <code><em>token</em>.stop_possible()</code> are <code>constexpr</code> epxressions yielding <code>false</code>. This concept is primarily used to avoid extra work when using stop tokens which will never indicate that cancellations are requested. </p><blockquote class="doxtable">
<details >
<summary >
Example</summary>
<p>The concept yields <code>true</code> for the <code><a href="‘#never-stop-token’">std::execution::never_stop_token</a></code>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">static_assert(std::execution::unstoppable_token&lt;std::execution::never_stop_token&gt;);</div>
<div class="line">static_assert(not std::execution::unstoppable_token&lt;std::execution::stop_token&gt;);</div>
<div class="line">static_assert(not std::execution::unstoppable_token&lt;std::execution::inline_stop_token&gt;);</div>
</div><!-- fragment --> </details>
</blockquote>
</details>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md3"></a>
Queries</h2>
<p><code>The queries are used to obtain properties associated with and object. Except <code><a href="‘#forwarding-query’">forwarding_query</a></code> and <code><a href="‘#get-env’">get_env</a></code> the queries work on <a href="‘#environment’">environments</a>.</code></p>
<p><code></p><details >
<summary >
<code>forwarding_query(<em>query</em>) -&gt; bool</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_env(<em>queryable</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_allocator(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_completion_scheduler(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_completion_signatures(<em>sender</em>, <em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_delegation_scheduler(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_domain(<em>env</em>)</code></summary>
<p></p>
<p></p>
</details>
<details >
<summary >
<code>get_forward_progress_guarantee(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_scheduler(<em>env</em>)</code></summary>
<p></p>
</details>
<details >
<summary >
<code>get_stop_token(<em>env</em>)</code></summary>
<p></p>
</details>
<p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md4"></a>
Customization Point Objects</h3>
<p><code></p><ul>
<li><code>connect(<em>sender, receiver</em>) -&gt; <em>operation_state</em></code></li>
<li><code>set_error(<em>error</em>) noexcept -&gt; void</code></li>
<li><code>set_stopped(<em>receiver</em>) noexcept -&gt; void</code></li>
<li><code>set_value(<em>receiver, value...</em>) noexcept -&gt; void</code></li>
<li><code>start(<em>state&amp;</em>) noexcept -&gt; void</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md5"></a>
Senders</h2>
<p><code> </code></p>
<h3><a class="anchor" id="autotoc_md6"></a>
Sender Factories</h3>
<p><code></p><ul>
<li><code>just(<em>value...</em>) -&gt; <em>sender-of</em>&lt;set_value_t(<em>Value...</em>)&gt;</code></li>
<li><code>just_error(<em>error</em>) -&gt; <em>sender-of</em>&lt;set_error_t(<em>Error</em>)&gt;</code></li>
<li><code>just_stopped() -&gt; <em>sender-of</em>&lt;set_stopped_t()&gt;</code></li>
<li><code>read_env(<em>query</em>) -&gt; <em>sender-of</em>&lt;set_value_t(<em>query-result</em>)&gt;</code></li>
<li><code>schedule(<em>scheduler</em>) -&gt; <em>sender-of</em>&lt;set_value_t()&gt;</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md7"></a>
Sender Adaptors</h3>
<p><code></p><ul>
<li><code>bulk</code></li>
<li><code>continues_on(<em>sender</em>, <em>scheduler</em>) -&gt; <em>sender</em></code></li>
<li><code>into_variant(<em>sender</em>) -&gt; <em>sender-of</em>&lt;set_value_t(std::variant&lt;T...&gt;)&gt;</code>`</li>
<li><code>let_error(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>let_stopped(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>let_value(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>on</code></li>
<li><code>schedule_from(<em>scheduler</em>, <em>sender</em>) -&gt; <em>sender</em></code></li>
<li><code>split</code></li>
<li><code>starts_on(<em>scheduler</em>, <em>sender</em>) -&gt; <em>sender</em></code></li>
<li><code>stopped_as_error</code></li>
<li><code>stopped_as_optional</code></li>
<li><code>then(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>upon_error(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>upon_stopped(<em>upstream</em>, <em>fun</em>) -&gt; <em>sender</em></code></li>
<li><code>when_all(<em>sender</em>...) -&gt; <em>sender</em></code></li>
<li><code>when_all_with_variant(<em>sender</em>...) -&gt; <em>sender</em></code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h3><a class="anchor" id="autotoc_md8"></a>
Sender Consumers</h3>
<p><code></p><ul>
<li><code>sync_wait(<em>sender</em>) -&gt; std::optional&lt;std::tuple&lt;T...&gt;&gt;</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md9"></a>
Helpers</h2>
<p><code></p><ul>
<li><code>as_awaitable</code></li>
<li><code>with_awaitable_sender</code></li>
<li><code>apply_sender</code></li>
<li><code>completion_signatures</code></li>
<li><code>completion_signatures_t</code></li>
<li><code>connect_result_t</code></li>
<li><code>default_domain</code></li>
<li><code>empty_env</code></li>
<li><code>env_of_t</code></li>
<li><code>error_types_of_t</code></li>
<li><code>fwd_env</code></li>
<li><code>operation_state_t</code></li>
<li><code>receiver_t</code></li>
<li><code>run_loop</code></li>
<li><code>scheduler_t</code></li>
<li><code>schedule_result_t</code></li>
<li><code>sender_adaptor_closure</code></li>
<li><code>sender_t</code></li>
<li><code>stop_token_of_t</code></li>
<li><code>tag_of_t</code></li>
<li><code>transform_sender</code></li>
<li><code>transform_completion_signatures</code></li>
<li><code>transform_completion_signatures_of</code></li>
<li><code>value_types_of_t</code></li>
</ul>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md10"></a>
Stop Token</h2>
<p><code></p><ul>
<li><code>never_stop_token</code></li>
<li><code>stop_token</code></li>
<li><code>inplace_stop_token</code> </li>
</ul>
<p></code></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
